import { AsyncSubject, BehaviorSubject } from 'rxjs';
import jsQR from 'jsqr';
import { Injectable, Component, EventEmitter, ViewChild, ViewEncapsulation, NgModule, defineInjectable } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * MediaStream
 * Use facingMode: environment to attemt to get the front camera on phones
 * @type {?}
 */
const MEDIA_STREAM_DEFAULT = {
    audio: false,
    video: true
};
/** @type {?} */
const CONFIG_DEFAULT = {
    src: '',
    isAuto: false,
    isBeep: true,
    isAlwaysEmit: false,
    medias: MEDIA_STREAM_DEFAULT,
};
/**
 * Audio
 * Camera beep
 * @type {?}
 */
const CAMERA_BEEP = "data:audio/wav;base64,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qJrx4KOQjahZxWbcZgztj2c49nKmkId44S71j0c8eV9yDK6uPRzx5X18eDvjvQ6yKo9ZSS6l//8elePK/Lf//IInrOF/FvDoADYAGBMGb7FtErm5MXMlmPAJQVgWta7Zx2go+8xJ0UiCb8LHHdftWyLJE0QIAIsI+UbXu67dZMjmgDGCGl1H+vpF4NSDckSIkk7Vd+sxEhBQMRU8j/12UIRhzSaUdQ+rQU5kGeFxm+hb1oh6pWWmv3uvmReDl0UnvtapVaIzo1jZbf/pD6ElLqSX+rUmOQNpJFa/r+sa4e/pBlAABoAAAAA3CUgShLdGIxsY7AUABPRrgCABdDuQ5GC7DqPQCgbbJUAoRSUj+NIEig0YfyWUho1VBBBA//uQZB4ABZx5zfMakeAAAAmwAAAAF5F3P0w9GtAAACfAAAAAwLhMDmAYWMgVEG1U0FIGCBgXBXAtfMH10000EEEEEECUBYln03TTTdNBDZopopYvrTTdNa325mImNg3TTPV9q3pmY0xoO6bv3r00y+IDGid/9aaaZTGMuj9mpu9Mpio1dXrr5HERTZSmqU36A3CumzN/9Robv/Xx4v9ijkSRSNLQhAWumap82WRSBUqXStV/YcS+XVLnSS+WLDroqArFkMEsAS+eWmrUzrO0oEmE40RlMZ5+ODIkAyKAGUwZ3mVKmcamcJnMW26MRPgUw6j+LkhyHGVGYjSUUKNpuJUQoOIAyDvEyG8S5yfK6dhZc0Tx1KI/gviKL6qvvFs1+bWtaz58uUNnryq6kt5RzOCkPWlVqVX2a/EEBUdU1KrXLf40GoiiFXK///qpoiDXrOgqDR38JB0bw7SoL+ZB9o1RCkQjQ2CBYZKd/+VJxZRRZlqSkKiws0WFxUyCwsKiMy7hUVFhIaCrNQsKkTIsLivwKKigsj8XYlwt/WKi2N4d//uQRCSAAjURNIHpMZBGYiaQPSYyAAABLAAAAAAAACWAAAAApUF/Mg+0aohSIRobBAsMlO//Kk4soosy1JSFRYWaLC4qZBYWFRGZdwqKiwkNBVmoWFSJkWFxX4FFRQWR+LsS4W/rFRb/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VEFHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU291bmRib3kuZGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAwNGh0dHA6Ly93d3cuc291bmRib3kuZGUAAAAAAAAAACU=";

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * OVERRIDES
 * \@param variableKey
 * \@param config
 * \@param defaultConfig
 * \@return
 * @type {?}
 */
const OVERRIDES = (/**
 * @param {?} variableKey
 * @param {?} config
 * @param {?} defaultConfig
 * @return {?}
 */
(variableKey, config, defaultConfig) => {
    if (config && Object.keys(config[variableKey]).length) {
        for (const key in defaultConfig) {
            /** @type {?} */
            const cloneDeep = JSON.parse(JSON.stringify(Object.assign({}, config[variableKey], { [key]: ((/** @type {?} */ (defaultConfig)))[key] })));
            config[variableKey] = config[variableKey].hasOwnProperty(key) ? config[variableKey] : cloneDeep;
        }
        return config[variableKey];
    }
    else {
        return defaultConfig;
    }
});
/**
 * Rxjs complete
 * \@param as
 * \@param data
 * \@param error
 * @type {?}
 */
const AS_COMPLETE = (/**
 * @param {?} as
 * @param {?} data
 * @param {?=} error
 * @return {?}
 */
(as, data, error = null) => {
    error ? as.error(error) : as.next(data);
    as.complete();
});
/**
 * CAMERA_BEEP
 * \@param isPlay
 * \@return
 * @type {?}
 */
const PLAY_AUDIO = (/**
 * @param {?=} isPlay
 * @return {?}
 */
(isPlay = false) => {
    if (isPlay === false)
        return;
    /** @type {?} */
    const audio = new Audio(CAMERA_BEEP);
    // when the sound has been loaded, execute your code
    audio.oncanplaythrough = (/**
     * @return {?}
     */
    () => {
        /** @type {?} */
        const promise = audio.play();
        if (promise) {
            promise.catch((/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                if (e.name === "NotAllowedError" || e.name === "NotSupportedError") ;
            }));
        }
    });
});
/**
 * HAS_OWN_PROPERTY
 * Fix issue vs ng v 6-7-8
 * Optional chaining (?.) just have on ng v 9++
 * eg: HAS_OWN_PROPERTY(config, 'frameOptions.style') // output: boolean
 * \@param obj
 * \@param propertyPath
 * \@return
 * @type {?}
 */
const HAS_OWN_PROPERTY = (/**
 * @param {?} obj
 * @param {?} propertyPath
 * @return {?}
 */
(obj, propertyPath) => {
    /** @type {?} */
    const properties = propertyPath.split(".");
    for (let i = 0; i < properties.length; i++) {
        /** @type {?} */
        let prop = properties[i];
        if (!obj.hasOwnProperty(prop)) {
            return false;
        }
        else {
            obj = obj[prop];
        }
    }
    return true;
});
/**
 * DRAW_RESULT
 * \@param code
 * \@param oriCanvas
 * \@param elTarget
 * \@return
 * @type {?}
 */
const DRAW_RESULT = (/**
 * @param {?} code
 * @param {?} oriCanvas
 * @param {?} elTarget
 * @return {?}
 */
(code, oriCanvas, elTarget) => {
    /** @type {?} */
    let widthZoom;
    /** @type {?} */
    let heightZoom;
    /** @type {?} */
    let oriWidth = oriCanvas.width;
    /** @type {?} */
    let oriHeight = oriCanvas.height;
    /** @type {?} */
    let oriWHRatio = oriWidth / oriHeight;
    /** @type {?} */
    let imgWidth = parseInt(getComputedStyle(oriCanvas).width);
    /** @type {?} */
    let imgHeight = parseInt(getComputedStyle(oriCanvas).height);
    /** @type {?} */
    let imgWHRatio = imgWidth / imgHeight;
    /** @type {?} */
    let cvs = document.createElement("canvas");
    /** @type {?} */
    let ctx = (/** @type {?} */ (cvs.getContext('2d', { willReadFrequently: true })));
    ctx.globalCompositeOperation = "destination-over";
    /** @type {?} */
    let loc = {};
    loc.x1 = code.location.topLeftCorner.x;
    loc.y1 = code.location.topLeftCorner.y;
    loc.x2 = code.location.topRightCorner.x;
    loc.y2 = code.location.topRightCorner.y;
    loc.x3 = code.location.bottomLeftCorner.x;
    loc.y3 = code.location.bottomLeftCorner.y;
    loc.x4 = code.location.bottomRightCorner.x;
    loc.y4 = code.location.bottomRightCorner.y;
    /** @type {?} */
    let locXArr = [loc.x1, loc.x2, loc.x3, loc.x4];
    /** @type {?} */
    let locYArr = [loc.y1, loc.y2, loc.y3, loc.y4];
    /** @type {?} */
    let maxX = Math.max(loc.x1, loc.x2, loc.x3, loc.x4);
    /** @type {?} */
    let minX = Math.min(loc.x1, loc.x2, loc.x3, loc.x4);
    /** @type {?} */
    let maxY = Math.max(loc.y1, loc.y2, loc.y3, loc.y4);
    /** @type {?} */
    let minY = Math.min(loc.y1, loc.y2, loc.y3, loc.y4);
    /** @type {?} */
    let minXToY = locYArr[locXArr.indexOf(minX)];
    /** @type {?} */
    let minYToX = locXArr[locYArr.indexOf(minY)];
    /** @type {?} */
    let maxXToY = locYArr[locXArr.indexOf(maxX)];
    /** @type {?} */
    let maxYToX = locXArr[locYArr.indexOf(maxY)];
    if (oriWHRatio > imgWHRatio) {
        widthZoom = imgWidth / oriWidth;
        heightZoom = imgWidth / oriWHRatio / oriHeight;
        cvs.style.top = minY * heightZoom + (imgHeight - imgWidth / oriWHRatio) * 0.5 + "px";
        cvs.style.left = minX * widthZoom + "px";
        cvs.width = (maxX - minX) * widthZoom;
        cvs.height = (maxY - minY) * widthZoom;
        cvs.style.width = (maxX - minX) * widthZoom + "px";
        cvs.style.height = (maxY - minY) * widthZoom + "px";
    }
    else {
        heightZoom = imgHeight / oriHeight;
        widthZoom = (imgHeight * oriWHRatio) / oriWidth;
        cvs.style.top = minY * heightZoom + "px";
        cvs.style.left = minX * widthZoom + (imgWidth - imgHeight * oriWHRatio) * 0.5 + "px";
        cvs.width = (maxX - minX) * heightZoom;
        cvs.height = (maxY - minY) * heightZoom;
        cvs.style.width = (maxX - minX) * heightZoom + "px";
        cvs.style.height = (maxY - minY) * heightZoom + "px";
    }
    cvs.style.zIndex = '1';
    cvs.style.position = "absolute";
    ctx.fillStyle = "#55f02880";
    /** @type {?} */
    const isSquare = (/**
     * @return {?}
     */
    () => {
        /** @type {?} */
        const left = Math.floor(loc.x1) - Math.floor(loc.x3);
        /** @type {?} */
        const right = Math.floor(loc.x2) - Math.floor(loc.x4);
        return ~~left <= 1 && ~~right <= 1 && code.location.topLeftFinderPattern.y == code.location.topRightFinderPattern.y;
    });
    if (!isSquare()) {
        /** @type {?} */
        const h1 = minXToY * heightZoom - minY * heightZoom;
        /** @type {?} */
        const w1 = minYToX * widthZoom - minX * widthZoom;
        /** @type {?} */
        const h2 = maxXToY * heightZoom - minY * heightZoom;
        /** @type {?} */
        const w2 = maxYToX * widthZoom - minX * widthZoom;
        ctx.beginPath();
        ctx.moveTo(0, h1);
        ctx.lineTo(w1, 0);
        ctx.lineTo(cvs.width, h2);
        ctx.lineTo(w2, cvs.height);
        ctx.fill();
    }
    else {
        ctx.fillRect(0, 0, cvs.width, cvs.height);
    }
    // Tooltip result
    /** @type {?} */
    const qrcodeTooltipTemp = document.createElement('div');
    qrcodeTooltipTemp.setAttribute('class', 'qrcode-tooltip-temp');
    qrcodeTooltipTemp.innerHTML = code.data;
    // Tooltip box
    /** @type {?} */
    const qrcodeTooltip = document.createElement('div');
    qrcodeTooltip.setAttribute('class', 'qrcode-tooltip');
    qrcodeTooltip.appendChild(qrcodeTooltipTemp);
    heightZoom = imgHeight / oriHeight;
    widthZoom = (imgHeight * oriWHRatio) / oriWidth;
    qrcodeTooltip.style.fontSize = widthZoom * 15 + 'px';
    qrcodeTooltip.style.top = minY * heightZoom + "px";
    qrcodeTooltip.style.left = minX * widthZoom + (imgWidth - imgHeight * oriWHRatio) * 0.5 + "px";
    qrcodeTooltip.style.width = (maxX - minX) * heightZoom + "px";
    qrcodeTooltip.style.height = (maxY - minY) * heightZoom + "px";
    // Result text
    /** @type {?} */
    const resultText = document.createElement('input');
    resultText.value = code.data;
    resultText.style.zIndex = '3';
    resultText.style.fontSize = widthZoom * 15 + 'px';
    resultText.style.color = 'red';
    resultText.style.border = 'none';
    resultText.style.outline = 'none';
    resultText.style.position = 'absolute';
    resultText.style.background = '#ffffff00';
    resultText.style.width = '-webkit-fill-available';
    resultText.style.minWidth = qrcodeTooltip.style.width;
    resultText.setAttribute('class', 'qrcode-data');
    // Set position result text
    resultText.style.top = minY * heightZoom + (-20 * heightZoom) + "px";
    resultText.style.left = minX * widthZoom + (imgWidth - imgHeight * oriWHRatio) * 0.5 + "px";
    if (elTarget) {
        elTarget.innerHTML = '';
        elTarget.appendChild(cvs);
        elTarget.appendChild(resultText);
        elTarget.appendChild(qrcodeTooltip);
    }
    return cvs;
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxScannerQrcodeService {
    /**
     * Load files
     * @param {?=} files
     * @return {?} AsyncSubject
     */
    loadFiles(files = []) {
        /** @type {?} */
        const as = new AsyncSubject();
        Promise.all(Object.assign([], files).map((/**
         * @param {?} m
         * @return {?}
         */
        m => this.readAsDataURL(m)))).then((/**
         * @param {?} img
         * @return {?}
         */
        (img) => AS_COMPLETE(as, img))).catch((/**
         * @param {?} error
         * @return {?}
         */
        (error) => AS_COMPLETE(as, null, error)));
        return as;
    }
    /**
     * readAsDataURL
     * @private
     * @param {?} file
     * @return {?} Promise
     */
    readAsDataURL(file) {
        /** drawImage **/
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            /** @type {?} */
            const fileReader = new FileReader();
            fileReader.onload = (/**
             * @return {?}
             */
            () => {
                /** @type {?} */
                const objectFile = {
                    name: file.name,
                    file: file,
                    base64: (/** @type {?} */ (fileReader.result)),
                    url: URL.createObjectURL(file)
                };
                resolve(objectFile);
            });
            fileReader.onerror = (/**
             * @param {?} error
             * @return {?}
             */
            (error) => reject(error));
            fileReader.readAsDataURL(file);
        }));
    }
}
NgxScannerQrcodeService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ NgxScannerQrcodeService.ngInjectableDef = defineInjectable({ factory: function NgxScannerQrcodeService_Factory() { return new NgxScannerQrcodeService(); }, token: NgxScannerQrcodeService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxScannerQrcodeComponent {
    constructor() {
        /**
         * EventEmitter
         */
        this.error = new EventEmitter();
        this.event = new EventEmitter();
        /**
         * Input
         */
        this.src = CONFIG_DEFAULT.src;
        this.isAuto = CONFIG_DEFAULT.isAuto;
        this.isBeep = CONFIG_DEFAULT.isBeep;
        this.isAlwaysEmit = CONFIG_DEFAULT.isAlwaysEmit;
        this.config = CONFIG_DEFAULT;
        this.medias = CONFIG_DEFAULT.medias;
        /**
         * Export
         */
        this.isStart = false;
        this.isLoading = false;
        this.data = new BehaviorSubject({});
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.overrideConfig();
        if (this.src) {
            this.loadImage(this.src);
        }
        else if (this.isAuto) {
            this.start();
        }
        this.resize();
    }
    /**
     * start
     * @return {?} AsyncSubject
     */
    start() {
        /** @type {?} */
        const as = new AsyncSubject();
        if (this.isStart) {
            // Reject
            AS_COMPLETE(as, false);
        }
        else {
            // Loading on
            this.status(false, true);
            /**
             * MediaStream
             * Use facingMode: environment to attemt to get the front camera on phones
             */
            navigator.mediaDevices.getUserMedia(this.medias).then((/**
             * @param {?} stream
             * @return {?}
             */
            (stream) => {
                this.video.nativeElement.srcObject = stream;
                this.video.nativeElement.onloadedmetadata = (/**
                 * @return {?}
                 */
                () => {
                    this.video.nativeElement.play();
                    this.requestAnimationFrame();
                    this.status(true, false);
                    AS_COMPLETE(as, true);
                });
            })).catch((/**
             * @param {?} error
             * @return {?}
             */
            error => {
                this.status(false, false);
                this.eventEmit(false, error);
                AS_COMPLETE(as, false, error);
            }));
        }
        return as;
    }
    /**
     * stop
     * @return {?} AsyncSubject
     */
    stop() {
        this.eventEmit(null);
        this.status(false, false);
        /** @type {?} */
        const as = new AsyncSubject();
        try {
            this.removeCanvas();
            clearInterval(this.rAF_ID);
            ((/** @type {?} */ (this.video.nativeElement.srcObject))).getTracks().forEach((/**
             * @param {?} track
             * @return {?}
             */
            (track) => {
                track.stop();
                AS_COMPLETE(as, true);
            }));
        }
        catch (error) {
            this.eventEmit(false, error);
            AS_COMPLETE(as, false, (/** @type {?} */ (error)));
        }
        return as;
    }
    /**
     * play
     * @return {?} AsyncSubject
     */
    play() {
        /** @type {?} */
        const as = new AsyncSubject();
        if (this.isPause) {
            this.video.nativeElement.play();
            this.requestAnimationFrame();
            AS_COMPLETE(as, true);
        }
        else {
            AS_COMPLETE(as, false);
        }
        return as;
    }
    /**
     * pause
     * @return {?} AsyncSubject
     */
    pause() {
        /** @type {?} */
        const as = new AsyncSubject();
        if (this.isStart) {
            clearInterval(this.rAF_ID);
            this.video.nativeElement.pause();
            AS_COMPLETE(as, true);
        }
        else {
            AS_COMPLETE(as, false);
        }
        return as;
    }
    /**
     * loadImage
     * @param {?} src
     * @return {?}
     */
    loadImage(src) {
        /** @type {?} */
        const as = new AsyncSubject();
        // Loading on
        this.status(false, true);
        // Set the src of this Image object.
        /** @type {?} */
        const image = new Image();
        // Setting cross origin value to anonymous
        image.setAttribute('crossOrigin', 'anonymous');
        // When our image has loaded.
        image.onload = (/**
         * @return {?}
         */
        () => {
            this.drawImage(image, (/**
             * @param {?} flag
             * @return {?}
             */
            (flag) => {
                this.status(false, false);
                AS_COMPLETE(as, flag);
            }));
        });
        // Set src
        image.src = src;
        return as;
    }
    /**
     * window: resize
     * Draw again!
     * @private
     * @return {?}
     */
    resize() {
        window.addEventListener("resize", (/**
         * @return {?}
         */
        () => this.data.subscribe((/**
         * @param {?} res
         * @return {?}
         */
        res => {
            if (HAS_OWN_PROPERTY(res, 'location')) {
                DRAW_RESULT((/** @type {?} */ (res)), this.canvas.nativeElement, this.resultsPanel.nativeElement);
            }
        }))));
    }
    /**
     * Override config
     * @private
     * @return {?} void
     */
    overrideConfig() {
        if (HAS_OWN_PROPERTY(this.config, 'src'))
            this.src = this.config.src;
        if (HAS_OWN_PROPERTY(this.config, 'isAuto'))
            this.isAuto = this.config.isAuto;
        if (HAS_OWN_PROPERTY(this.config, 'isBeep'))
            this.isBeep = this.config.isBeep;
        if (HAS_OWN_PROPERTY(this.config, 'isAlwaysEmit'))
            this.isAlwaysEmit = this.config.isAlwaysEmit;
        if (HAS_OWN_PROPERTY(this.config, 'medias'))
            this.medias = OVERRIDES('medias', this.config, MEDIA_STREAM_DEFAULT);
    }
    /**
     * drawImage
     * @private
     * @param {?} element
     * @param {?=} callback
     * @return {?}
     */
    drawImage(element, callback = (/**
     * @return {?}
     */
    () => { })) {
        // Get the canvas element by using the getElementById method.
        /** @type {?} */
        const canvas = this.canvas.nativeElement;
        // Get a 2D drawing context for the canvas.
        /** @type {?} */
        const ctx = (/** @type {?} */ (canvas.getContext('2d', { willReadFrequently: true })));
        // HTMLImageElement size
        if (element instanceof HTMLImageElement) {
            canvas.width = element.naturalWidth;
            canvas.height = element.naturalHeight;
            element.style.visibility = '';
            this.video.nativeElement.style.visibility = 'hidden';
        }
        // HTMLVideoElement size
        if (element instanceof HTMLVideoElement) {
            canvas.width = element.videoWidth;
            canvas.height = element.videoHeight;
            element.style.visibility = '';
            this.canvas.nativeElement.style.visibility = 'hidden';
        }
        // Draw image
        ctx.drawImage(element, 0, 0, canvas.width, canvas.height);
        // Data image
        /** @type {?} */
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        // Draw frame
        /** @type {?} */
        const code = jsQR(imageData.data, imageData.width, imageData.height, { inversionAttempts: "attemptBoth" });
        if (code) {
            DRAW_RESULT(code, Object.freeze(this.canvas.nativeElement), this.resultsPanel.nativeElement);
            // toBlob and emit data
            /** @type {?} */
            const EMIT_DATA = (/**
             * @return {?}
             */
            () => this.eventEmit(Object.assign({}, code, { canvas: canvas })));
            // HTMLImageElement
            if (element instanceof HTMLImageElement) {
                callback(true);
                EMIT_DATA();
                PLAY_AUDIO(this.isBeep);
            }
            // HTMLVideoElement
            if (element instanceof HTMLVideoElement) {
                if (this.isAlwaysEmit) {
                    EMIT_DATA();
                    PLAY_AUDIO(this.isBeep);
                }
                else if (code.data !== ((/** @type {?} */ (this.data.value)))['data']) {
                    EMIT_DATA();
                    PLAY_AUDIO(this.isBeep);
                }
            }
        }
        else {
            callback(false);
            this.removeCanvas();
        }
    }
    /**
     * removeCanvas
     * @private
     * @return {?}
     */
    removeCanvas() {
        Object.assign([], this.resultsPanel.nativeElement.childNodes).forEach((/**
         * @param {?} el
         * @return {?}
         */
        el => this.resultsPanel.nativeElement.removeChild(el)));
    }
    /**
     * status
     * @private
     * @param {?} isStart
     * @param {?} isLoading
     * @return {?}
     */
    status(isStart, isLoading) {
        this.isStart = isStart;
        this.isLoading = isLoading;
    }
    /**
     * eventEmit
     * @private
     * @param {?=} response
     * @param {?=} error
     * @return {?}
     */
    eventEmit(response = false, error = false) {
        (response !== false) && this.data.next(response || { data: null });
        (response !== false) && this.event.emit(response || { data: null });
        (error !== false) && this.error.emit(error || null);
    }
    /**
     * Single-thread
     * Loop Recording on Camera
     * Must be destroy request
     * requestAnimationFrame
     * @private
     * @return {?}
     */
    requestAnimationFrame() {
        this.rAF_ID = setInterval((/**
         * @return {?}
         */
        () => {
            if (this.video.nativeElement.readyState === this.video.nativeElement.HAVE_ENOUGH_DATA) {
                this.drawImage(this.video.nativeElement);
            }
        }), 40);
    }
    /**
     * Status of camera
     * @return {?} boolean
     */
    get isPause() {
        return this.isStart && this.video.nativeElement.paused;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.pause();
    }
}
NgxScannerQrcodeComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-scanner-qrcode',
                template: "<div #resultsPanel class=\"origin-overlay\"></div>\r\n<canvas #canvas class=\"origin-canvas\"></canvas>\r\n<video #video playsinline class=\"origin-video\"></video>",
                host: { 'class': 'ngx-scanner-qrcode' },
                exportAs: 'scanner',
                inputs: ['src', 'isAuto', 'isBeep', 'isAlwaysEmit', 'config', 'medias'],
                outputs: ['event', 'error'],
                queries: {
                    video: new ViewChild('video'),
                    canvas: new ViewChild('canvas'),
                    resultsPanel: new ViewChild('resultsPanel')
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".ngx-scanner-qrcode{width:100%;position:relative;background-color:#262626;display:flex;justify-content:center;align-items:center}.origin-overlay{position:absolute;width:100%;height:100%}.origin-canvas{-o-object-fit:contain;object-fit:contain;position:absolute;width:100%;height:100%}.origin-video{width:100%;height:100%}.qrcode-tooltip{position:absolute;z-index:2}.qrcode-tooltip:hover .qrcode-tooltip-temp{display:block;position:absolute}.qrcode-tooltip-temp{bottom:0;z-index:3;left:50%;padding:10px;display:none;width:-moz-max-content;width:max-content;word-wrap:break-word;max-width:450px;box-shadow:1px 1px 20px #000000e0;border-radius:5px;background-color:#000000d0;transform:translate(-50%);transform-style:preserve-3d;color:#fff;text-align:left}.qrcode-data{position:absolute;top:-20px;color:red}"]
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxScannerQrcodeModule {
}
NgxScannerQrcodeModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NgxScannerQrcodeComponent],
                exports: [NgxScannerQrcodeComponent],
                providers: [NgxScannerQrcodeService],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgxScannerQrcodeService, NgxScannerQrcodeComponent, NgxScannerQrcodeModule };

//# sourceMappingURL=ngx-scanner-qrcode.js.map